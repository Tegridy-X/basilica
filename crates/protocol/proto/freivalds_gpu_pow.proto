// Freivalds GPU Proof-of-Work Protocol
// Asymmetric verification using Freivalds' algorithm
// Version: 1.0

syntax = "proto3";

package basilca.freivalds_gpu_pow.v1;

import "google/protobuf/timestamp.proto";
import "gpu_pow.proto";

// Initial challenge parameters for Freivalds protocol
message FreivaldsChallenge {
  // Unique session ID for tracking multi-round protocol
  string session_id = 1;
  
  // Matrix dimension N for N x N matrices
  uint32 n = 2;
  
  // Master seed for deterministic matrix generation (16 bytes)
  bytes master_seed = 3;
  
  // Challenge timestamp
  google.protobuf.Timestamp timestamp = 4;
  
  // Expected GPU configuration (for symmetric verification fallback)
  uint32 expected_gpu_count = 5;
}

// Commitment response from miner after computing C = A × B
message CommitmentResponse {
  // Session ID this commitment belongs to
  string session_id = 1;
  
  // Merkle root of matrix C rows (32 bytes)
  bytes merkle_root = 2;
  
  // Number of rows in matrix C
  uint32 row_count = 3;
  
  // Execution metadata
  ExecutionMetadata metadata = 4;
  
  // Commitment timestamp
  google.protobuf.Timestamp timestamp = 5;
}

// Verification request from validator with challenge vector
message FreivaldsVerification {
  // Session ID for this verification
  string session_id = 1;
  
  // Random challenge vector r (base64 encoded float array)
  bytes challenge_vector = 2;
  
  // Indices of rows to spot-check
  repeated uint32 spot_check_rows = 3;
  
  // Verification timestamp
  google.protobuf.Timestamp timestamp = 4;
}

// Row proof for spot-checking
message RowProof {
  // Row index in matrix C
  uint32 row_idx = 1;
  
  // Row data (base64 encoded float array)
  bytes row_data = 2;
  
  // Merkle proof path (list of 32-byte hashes)
  repeated bytes merkle_path = 3;
}

// Response containing C·r and row proofs
message FreivaldsResponse {
  // Session ID for this response
  string session_id = 1;
  
  // C·r result (base64 encoded float array)
  bytes cr_result = 2;
  
  // Proofs for requested rows
  repeated RowProof row_proofs = 3;
  
  // Response timestamp
  google.protobuf.Timestamp timestamp = 4;
}

// Final verification result
message FreivaldsVerificationResult {
  // Session ID that was verified
  string session_id = 1;
  
  // Whether Freivalds check passed
  bool freivalds_valid = 2;
  
  // Whether all spot checks passed
  bool spot_checks_valid = 3;
  
  // Number of spot checks performed
  uint32 spot_checks_performed = 4;
  
  // Number of spot checks passed
  uint32 spot_checks_passed = 5;
  
  // Overall verification passed
  bool verified = 6;
  
  // Verification message
  string message = 7;
  
  // Performance metrics
  PerformanceMetrics metrics = 8;
  
  // Result timestamp
  google.protobuf.Timestamp timestamp = 9;
}

// Execution metadata from miner
message ExecutionMetadata {
  // GPU configuration used
  repeated GpuInfo gpus = 1;
  
  // Total execution time in milliseconds
  uint64 execution_time_ms = 2;
  
  // Total VRAM allocated in MB
  uint64 vram_allocated_mb = 3;
  
  // Matrix multiplication kernel time in ms
  uint64 kernel_time_ms = 4;
  
  // Merkle tree construction time in ms
  uint64 merkle_time_ms = 5;
}

// GPU information
message GpuInfo {
  // GPU device ID
  uint32 device_id = 1;
  
  // GPU model name
  string model = 2;
  
  // VRAM in MB
  uint64 vram_mb = 3;
  
  // Number of SMs/CUs
  uint32 compute_units = 4;
}

// Performance metrics for verification
message PerformanceMetrics {
  // Freivalds verification time in ms
  uint64 freivalds_time_ms = 1;
  
  // Spot check verification time in ms
  uint64 spot_check_time_ms = 2;
  
  // Total verification time in ms
  uint64 total_time_ms = 3;
  
  // Estimated computation saved (percentage)
  double computation_saved_percent = 4;
}

// Service definition for Freivalds GPU PoW
service FreivaldsGpuPowValidator {
  // Phase 1: Request initial challenge (n, seed)
  rpc InitiateChallenge(InitiateChallengeRequest) returns (FreivaldsChallenge);
  
  // Phase 2: Submit commitment (merkle root)
  rpc SubmitCommitment(CommitmentResponse) returns (FreivaldsVerification);
  
  // Phase 3: Submit response (C·r and row proofs)
  rpc SubmitResponse(FreivaldsResponse) returns (FreivaldsVerificationResult);
  
  // Cancel an active session
  rpc CancelSession(CancelSessionRequest) returns (CancelSessionResponse);
}

// Request to initiate a new challenge
message InitiateChallengeRequest {
  // Executor ID requesting the challenge
  string executor_id = 1;
  
  // Claimed GPU configuration
  repeated GpuInfo claimed_gpus = 2;
  
  // Preferred matrix size (validator may adjust)
  uint32 preferred_n = 3;
}

// Request to cancel a session
message CancelSessionRequest {
  // Session ID to cancel
  string session_id = 1;
  
  // Reason for cancellation
  string reason = 2;
}

// Response to session cancellation
message CancelSessionResponse {
  // Whether cancellation succeeded
  bool success = 1;
  
  // Response message
  string message = 2;
}

// Combined challenge type for hybrid mode
message HybridGpuChallenge {
  // Challenge type selector
  oneof challenge {
    // Traditional symmetric challenge (defined in gpu_pow.proto)
    basilca.gpu_pow.v1.GpuPowChallenge symmetric_challenge = 1;
    
    // Freivalds asymmetric challenge
    FreivaldsChallenge freivalds_challenge = 2;
  }
  
  // Which mode to use
  ChallengeMode mode = 3;
}

// Challenge mode selector
enum ChallengeMode {
  // Unspecified mode
  MODE_UNSPECIFIED = 0;
  
  // Traditional symmetric verification
  MODE_SYMMETRIC = 1;
  
  // Freivalds asymmetric verification
  MODE_FREIVALDS = 2;
  
  // Validator chooses based on resources
  MODE_AUTO = 3;
}